<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Maze</title>
	<style>
	#x {
		transform: rotate(90deg) translate(60px, 10px)
	}
	body {
		zoom: 250%;
	}
	body > div{
		visibility: collapse;
		display: none;
		box-shadow: none;
	}
	div#not {
		visibility: visible;
		display: block;
	}
	</style>
</head>
<body>
<div id="not">
<div>
<input type="range" min="3" max="100" id="y"/>
<input type="checkbox" id="solve">
<input type="range" min="3" max="100" id="x"/>
</div>
<canvas id="canvas"></canvas><br />
<button onclick="gen_maze(lastx, lasty); if(dosolve.checked){solve_maze_no_vis()}">REGEN</button>
</div>
<script>
var gmap = []
const canvas = document.getElementById("canvas")
const xslider = document.getElementById("x")
const yslider = document.getElementById("y")
const dosolve = document.getElementById("solve")
const c = canvas.getContext("2d")
var tile_size = 1
const optionsX = [0, 2, 0, -2];
const optionsY = [-2, 0, 2, 0];

function draw_all() {
	for (var xp = 0; xp < gmap[0].length; xp++) {
		for (var yp = -1; yp < gmap.length-1; yp++) {
			c.beginPath();
			if (yp == -1 || gmap[yp][xp] == 0) {
				c.fillStyle = "rgb(0,0,0)"
			} else if (gmap[yp][xp] == 2) {
				c.fillStyle = "rgb(255,0,0)"
			} else if (gmap[yp][xp] == 3) {
				c.fillStyle = "rgb(255,200,0)"
			} else if (gmap[yp][xp] == 40) {
				c.fillStyle = "rgb(0,0,255)"
			} else if (gmap[yp][xp] == 50) {
				c.fillStyle = "rgb(0,255,255)"
			} else {
				c.fillStyle = "rgb(255,255,255)"
			}
			c.rect(tile_size*xp, tile_size*(yp+1), tile_size, tile_size);
			c.fill();
		}
	}
}

function gen_maze(sizeX, sizeY)
{
	var fails = 0;
	var posibX = [];
	var posibY = [];
	var mapSizeX = sizeX * 2+1;
	var mapSizeY = sizeY * 2+1;
	var map = Array(mapSizeX).fill(0).map(x => Array(mapSizeY).fill(0));
	var path = [];
	var x = Math.floor(Math.random() * sizeX) * 2;//0
	var y = 1;
	map[x][0] = 1;
	//console.log(map)

	map[x][y] = 1;
	path.push([x, y])
	//console.log(x + " " + y);
	//console.log("");
	var found = false;
	while (!found)
	{
		//Check for posibilities
		posibX = [];
		posibY = [];

		for (var i = 0; i < 4; i++)
		{
			var resultX = x + optionsX[i];
			var resultY = y + optionsY[i];
			if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || resultY > (mapSizeY-2) || map[resultX][resultY] == 1))
			{
				posibX.push(optionsX[i]);
				posibY.push(optionsY[i]);
			}
		}
		if (posibX.length != 0)
		{
			var choice = Math.round(Math.random() * (posibX.length-1));
			//console.log(posibX[choice], posibY[choice])
			//console.log(x + (posibX[choice] / 2), y + (posibY[choice] / 2))
			map[x + (posibX[choice] / 2)][y + (posibY[choice] / 2)] = 1;
			
			x += posibX[choice];
			y += posibY[choice];
			map[x][y] = 1;
			path.push([x, y]);
		}
		else
		{
			if (fails < ((sizeX+sizeY)/2*5))
			{
				var choice = Math.ceil(Math.random() * (path.length-1));
				//console.log(path, choice)
				x = path[choice][0];
				y = path[choice][1];
				fails++;
			}
			else
			{
				found = true;
			}

		}
		if (y > mapSizeY - 3)// && path.length >= (sizeX * sizeY))
		{
			
		}

	}
	
	canvas.width = tile_size*(sizeY * 2+1)
	canvas.height = tile_size*(sizeX * 2+1)
	//gmap = map.slice()
	//draw_all()
	
	/*var holesFound = 1;
	var times = 0;
	while (holesFound != 0)
	{
		holesFound = 0;
		if (times < 10)
		{
			for (var hX = 0; hX < sizeX; hX++)
			{
				for (var hY = 0; hY < sizeY; hY++)
				{
					if (map[hX * 2][hY * 2+1] == 0)
					{
						holesFound++;
						var done = false;
						var first = true;
						var fX = hX * 2;
						var fY = hY * 2+1;
						var isit = 0
						for (var i = 0; i < 4; i++)
							{
								var resultX = fX + optionsX[i];
								var resultY = fY + optionsY[i];
								
								if (resultX < 0 || resultX > (mapSizeX-2))
								{
										
									isit += 1
								}
								else if (resultY < 0 || resultY > (mapSizeY-2))
								{
										
									isit += 1
								}
								else if (map[resultX][resultY] == 0)
								{
										
									isit += 1
								}
						}
						
						//if (isit < 4 && isit > 0) {
						console.log(fX, fY, isit)
						map[fX, fY] = 1
						//holesFound = 19
						while (!done)
						{
							posibX = [];
							posibY = [];
							for (var i = 0; i < 4; i++)
							{
								var resultX = fX + optionsX[i];
								var resultY = fY + optionsY[i];
								if (first)
								{
									if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || resultY > (mapSizeY-2)) && map[resultX][resultY] == 1)
									{
										
										posibX.push(optionsX[i]);
										posibY.push(optionsY[i]);
									}
								}
								else
								{
									if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || resultY > (mapSizeY-2) || map[resultX][resultY] == 1))
									{
										posibX.push(optionsX[i]);
										posibY.push(optionsY[i]);
									}
								}
								
							}
							
							if (posibX.length != 0)
							{
								var choice = Math.round(Math.random() * (posibX.length-1));
								//console.log(choice, posibX.length)
								map[fX + (posibX[choice] / 2)][fY + (posibY[choice] / 2)] = 1;
								if (first)
								{	
									first = false;
									map[fX + posibX[choice]][fY + posibY[choice]] = 1;
									
								}
								else
								{
									fX += posibX[choice];
									fY += posibY[choice];
									map[fX][fY] = 1;
								}
								
								
							}
							else
							{
								done = true;
							}
							
						}
						

					}
				}
				//console.log("HOLES", holesFound)
			}
			times++;
		}
	}*/
	var holesFound = 100;
	var times = 0;
	while (holesFound != 0)
	{
		holesFound = 0;
		if (times < 100)
		{
			for (var hX = 0; hX < sizeX; hX++)
			{
				for (var hY = 0; hY < sizeY; hY++)
				{
					if (map[hX * 2][hY * 2 + 1] == 0)
					{
						holesFound++;
						var done = false;
						var first = true;
						var fX = hX * 2;
						var fY = hY * 2 + 1;
						var isit = 0
						for (var i = 0; i < 4; i++)
						{
							var resultX = fX + optionsX[i];
							var resultY = fY + optionsY[i];
								
							if (resultX < 0 || resultX > (mapSizeX-2))
							{
										
								isit += 1
							}
							else if (resultY < 0 || resultY > (mapSizeY-2))
							{
										
								isit += 1
							}
							else if (map[resultX][resultY] == 0)
							{
										
								isit += 1
							}
						}
						
						if (isit < 4) {
						map[fX][fY] = 1;
						while (!done)
						{
							posibX = [];
							posibY = [];
							for (var i = 0; i < 4; i++)
							{
								var resultX = fX + optionsX[i];
								var resultY = fY + optionsY[i];
								if (first)
								{
									if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || resultY > (mapSizeY-2)) && map[resultX][resultY] == 1)
									{
										posibX.push(optionsX[i]);
										posibY.push(optionsY[i]);
									}
								}
								else
								{
									if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || resultY > (mapSizeY-2) || map[resultX][resultY] == 1))
									{
										posibX.push(optionsX[i]);
										posibY.push(optionsY[i]);
									}
								}
								
							}
							
							if (posibX.length != 0)
							{
								var choice = Math.round(Math.random() * (posibX.length-1));
								//console.log(choice, fX, posibX, posibY)
								map[fX + (posibX[choice] / 2)][fY + (posibY[choice] / 2)] = 1;
								if (first)
								{
									first = false;
									map[fX + posibX[choice]][fY + posibY[choice]] = 1;
								}
								else
								{
									fX += posibX[choice];
									fY += posibY[choice];
									map[fX][fY] = 1;
								}
								
								
							}
							else
							{
								done = true;
							}
							
						}}
						

					}
				}
				//console.log("HOLES", holesFound)
			}
			times++;
		}
		
	}
	console.log(times)
	map[Math.floor(Math.random() * sizeX) * 2][mapSizeY-1] = 1;
	//map[mapSizeX-3][mapSizeY-1] = 1;
	gmap = map
	draw_all()
}
function draw_all_path(cl=false) {
	for (var xp = 0; xp < gmap[0].length; xp++) {
		for (var yp = -1; yp < gmap.length-1; yp++) {
			c.beginPath();
			if (yp != -1 && (gmap[yp][xp] == 2 || cl && [2,3].includes(gmap[yp][xp]))) {
				gmap[yp][xp] = 1
				c.fillStyle = "rgb(255,0,0)"
			} else if (yp != -1 && gmap[yp][xp] == 3) {
				gmap[yp][xp] = 1
				c.fillStyle = "rgb(255,200,0)"
			} else if (yp != -1 && gmap[yp][xp] == 4 && !cl) {
				gmap[yp][xp] = 1
				c.fillStyle = "rgb(0,0,255)"
			} else if (yp != -1 && gmap[yp][xp] != 0) {
				c.fillStyle = "rgb(255,255,255)"
				gmap[yp][xp] = 1
			}
			else {c.fillStyle = "rgb(0,0,0)"}
			c.rect(tile_size*xp, tile_size*(yp+1), tile_size, tile_size);
			c.fill();
			
		}
	}
}

function draw(yp, xp, col) {
	c.beginPath();
	if (yp == -1 || col == 0) {
		c.fillStyle = "rgb(0,0,0)"
	} else if (col == 2) {
		c.fillStyle = "rgb(255,0,0)"
	} else if (col == 3) {
		c.fillStyle = "rgb(255,200,0)"
	} else if (col == 4) {
		c.fillStyle = "rgb(0,0,255)"
	} else {
		c.fillStyle = "rgb(255,255,255)"
	}
	c.rect(tile_size*xp, tile_size*(yp+1), tile_size, tile_size);
	c.fill();
}

function solve_maze() {
	draw_all()
	if (gmap != []) {
	var start = null
	var mapSizeX = canvas.height/tile_size;
	var mapSizeY = canvas.width/tile_size;
	console.log(mapSizeX, mapSizeY)
	for (var i = 0; i < (canvas.height/tile_size+1)/2-1; i++) {
		if (gmap[i*2][0] == 1) {start = i; break}
	}
	//console.log(start)
	var x = start*2
	var y = 1
	console.log(x, y)
	var cross = []
	var path = [] 
	var back = false
	var choice = 0
	var inter = setInterval(() => {
		posibX = [];
		posibY = [];

		for (var i = 0; i < 4; i++)
		{
			var resultX = x + optionsX[i]/2;
			var resultY = y + optionsY[i]/2;
			if (!back) {
			if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || gmap[resultX][resultY] != 1)) {
				posibX.push(optionsX[i]/2);
				posibY.push(optionsY[i]/2);
			}} else {
			if (resultX >= 0 && resultX <= (mapSizeX-2) && resultY >= 0 && (gmap[resultX][resultY] == 1 || gmap[resultX][resultY] == 2 || gmap[resultX][resultY] == 3)) {
				posibX.push(optionsX[i]/2);
				posibY.push(optionsY[i]/2);
			}}
		}
		//console.log(posibX, posibY)
		if (posibX.length != 0)	{
			//console.log(x, y)
			if (back) {
				gmap[x][y] = 4
				draw(x,y,4)
			}
			choice = Math.round(Math.random() * (posibX.length-1))
			if (posibX.length > 1 && y + posibY[choice] != 0) {
				cross.push([x,y])
				gmap[x][y] = 3
				draw(x,y,3)
			}
			x += posibX[choice]
			y += posibY[choice]
			if (gmap[x][y] == 3) {
				back = false
			}
			if (!back) {
				draw(x,y,2)
				gmap[x][y] = 2	
			} 
			else {
				draw(x,y,4)
				gmap[x][y] = 4
			}
			//console.log(x,y)
		}
		else if (mapSizeY-1 == y) {
			//console.log("y"); 
			clearInterval(inter)
		}
		else {
			if (back) {clearInterval(inter)}
			back = true
			//console.log(back)
			if (gmap[x][y] == 3) {
				cross.pop()
			}
		}
			
			
		
	}, 0)
	draw_all_path()
	draw_all()
	}
}
function solve_maze_no_vis(cl=true) {
	if (gmap != []) {
	var start = null
	var mapSizeX = canvas.height/tile_size;
	var mapSizeY = canvas.width/tile_size;
	//console.log(mapSizeX, mapSizeY)
	for (var i = 0; i < (canvas.height/tile_size+1)/2-1; i++) {
		if (gmap[i*2][0] == 1) {start = i; break}
	}
	//console.log(start)
	//for (var n = 0; n < 20; n++) {
	var x = start*2
	var y = 1
	//console.log(x, y)
	var cross = []
	var path = [] 
	var back = false
	var choice = 0
	var moves = 0
	while (true) {
		moves++
		
		posibX = [];
		posibY = [];

		for (var i = 0; i < 4; i++)
		{
			var resultX = x + optionsX[i]/2;
			var resultY = y + optionsY[i]/2;
			if (!back) {
			if (!(resultX < 0 || resultX > (mapSizeX-2) || resultY < 0 || gmap[resultX][resultY] != 1)) {
				posibX.push(optionsX[i]/2);
				posibY.push(optionsY[i]/2);
			}} else {
			if (resultX >= 0 && resultX <= (mapSizeX-2) && resultY >= 0 && (gmap[resultX][resultY] == 1 || gmap[resultX][resultY] == 2 || gmap[resultX][resultY] == 3)) {
				posibX.push(optionsX[i]/2);
				posibY.push(optionsY[i]/2);
			}}
		}
		//console.log(posibX, posibY)
		if (posibX.length != 0)	{
			//console.log(x, y)
			if (back) {
				gmap[x][y] = 4
			}
			choice = Math.round(Math.random() * (posibX.length-1))
			if (posibX.length > 1 && y + posibY[choice] != 0) {
				cross.push([x,y])
				gmap[x][y] = 3
			}
			x += posibX[choice]
			y += posibY[choice]
			if (gmap[x][y] == 3) {
				back = false
			}
			if (!back) {
				gmap[x][y] = 2	
			} 
			else {
				gmap[x][y] = 4
			}
			//console.log(x,y)
		}
		else if (mapSizeY-1 == y) {
			//console.log("y"); 
			break
		}
		else {
			if (back) {break; console.log("error")}
			back = true
			//console.log(back)
			if (gmap[x][y] == 3) {
				cross.pop()
			}
		}
			
			
		
	}
	}
	//console.log(moves)
	all_moves.push(moves)
	if (cl) {draw_all_path(true)} else {draw_all_path()}
	
}

function count_it() {
	var moves_dict = {}
	all_moves.forEach(el => {
		if (moves_dict[Math.round(el/100)*100] == undefined) {
			moves_dict[Math.round(el/100)*100] = 1
		} else {
			moves_dict[Math.round(el/100)*100]++
		}
	})
	console.log(moves_dict)
	var lst1 = []
	var lst2 = Object.keys(moves_dict)
	for (var i = 0; i < Object.keys(moves_dict).length; i++) {lst1.push(moves_dict[Object.keys(moves_dict)[i]])}
	console.log(lst1, lst2)
}
function generate(x) {
	var i = 0
	var inter = setInterval(() => {
		for (var a = 0; a<100; a++){solve_maze_no_vis()} 
		console.log((i+1)*100,"/",i*100)
		i++
		if (i == x) {clearInterval(inter); count_it()}
	}, 0)
}
function change_enter () {
	var start = null
	var end = null
	for (var i = 0; i < (canvas.height/tile_size+1)/2-1; i++) {
		if (gmap[i*2][0] == 1) {start = i; break}
	}
	for (var i = 0; i < (canvas.height/tile_size+1)/2-1; i++) {
		if (gmap[i*2][gmap.length-1] == 1) {end = i; break}
	}
	//console.log(start, end)
	draw(start*2, 0, 0)
	draw(end*2, gmap.length-1, 0)
	gmap[start*2][0] = 0;
	gmap[end*2][gmap.length-1] = 0;
	var a = Math.floor(Math.random() * (gmap.length/2-1)) * 2
	var b = Math.floor(Math.random() * (gmap.length/2-1)) * 2
	gmap[a][0] = 1;
	draw(a, 0, 1)
	gmap[b][gmap[0].length-1] = 1;
	draw(b, gmap[0].length-1, 1)
}
var all_moves = []
gen_maze(50, 50)
var lastx = 50
var lasty = 50
xslider.addEventListener("change",function(e){gen_maze(xslider.value, lasty);lastx = xslider.value;if(dosolve.checked){solve_maze_no_vis()}})
yslider.addEventListener("change",function(e){gen_maze(lastx, yslider.value);lasty = yslider.value;if(dosolve.checked){solve_maze_no_vis()}})
dosolve.addEventListener("change",function(e){if(dosolve.checked){solve_maze_no_vis()}else{draw_all_path(true)}})
</script>
